<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AI ç‰§å¸« - ä½ çš„éš¨èº«éˆä¿®å°å¸«</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React Framework -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Three.js for 3D rendering -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js" 
            onload="console.log('âœ… Three.js è¼‰å…¥æˆåŠŸ'); window.THREE_LOADED = true; if(window.THREE) window.dispatchEvent(new Event('threejsloaded'));" 
            onerror="console.error('âŒ Three.js è¼‰å…¥å¤±æ•—'); window.THREE_LOADED = false;"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* å›ºå®šæ•´å€‹é é¢ï¼Œé˜²æ­¢æ»‘å‹• */
        html {
            height: 100%;
            height: 100dvh;
            width: 100%;
            overflow: hidden;
            position: fixed;
            touch-action: none;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
        
        body { 
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a1a 50%, #0a1a0a 100%);
            background-attachment: fixed;
            margin: 0;
            padding: 0;
            overflow: hidden;
            overflow-x: hidden;
            overflow-y: hidden;
            width: 100%;
            height: 100%;
            height: 100dvh;
            position: fixed;
            touch-action: pan-y;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* é˜²æ­¢æ–‡å­—é¸æ“‡ï¼ˆå¯é¸ï¼Œå¦‚æœéœ€è¦å¯ä»¥ç§»é™¤ï¼‰ */
        * {
            -webkit-tap-highlight-color: transparent;
        }
        
        /* å…è¨±è¼¸å…¥æ¡†é¸æ“‡æ–‡å­— */
        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }
        .font-serif { font-family: 'Noto Serif TC', serif; }
        
        /* å„ªé›…çš„æ»¾å‹•æ¢è¨­è¨ˆ */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.02); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { 
            background: linear-gradient(180deg, #cbd5e1 0%, #94a3b8 100%);
            border-radius: 10px;
            transition: background 0.3s ease;
        }
        ::-webkit-scrollbar-thumb:hover { 
            background: linear-gradient(180deg, #94a3b8 0%, #64748b 100%);
        }
        
        /* å‹•ç•«æ•ˆæœ */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes shimmer {
            0% { background-position: -1000px 0; }
            100% { background-position: 1000px 0; }
        }
        
        .message-enter {
            animation: fadeInUp 0.4s ease-out;
        }
        
        .button-press {
            animation: pulse 0.2s ease-out;
        }
        
        /* éŸ¿æ‡‰å¼å„ªåŒ– */
        @media (max-width: 640px) {
            /* æ‰‹æ©Ÿå„ªåŒ– */
            body {
                font-size: 14px;
            }
            /* ç¢ºä¿åœ¨æ‰‹æ©Ÿä¸Šæ‰€æœ‰é—œéµå…ƒç´ éƒ½èƒ½é¡¯ç¤º */
            #root {
                height: 100vh;
                height: 100dvh; /* ä½¿ç”¨å‹•æ…‹è¦–çª—é«˜åº¦ï¼Œè€ƒæ…®ç€è¦½å™¨ UI */
                width: 100%;
                overflow: hidden;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
            }
            
            /* å›ºå®š header é«˜åº¦ - é€²ä¸€æ­¥æ¸›å°‘ */
            header {
                height: 38px !important;
                min-height: 38px !important;
                max-height: 38px !important;
                padding: 0.25rem 0.5rem !important;
            }
            
            /* Header æ¨™é¡Œæ–‡å­—æ›´å° */
            header h1 {
                font-size: 0.75rem !important;
                line-height: 1.2 !important;
            }
            
            /* å›ºå®šæ¨¡å¼åˆ‡æ›é«˜åº¦ - é€²ä¸€æ­¥æ¸›å°‘ */
            .mode-toggle-container {
                height: 36px !important;
                min-height: 36px !important;
                max-height: 36px !important;
                padding: 0.25rem !important;
            }
            
            /* æ¨¡å¼åˆ‡æ›æŒ‰éˆ•æ›´å° */
            .mode-toggle-container button {
                padding: 0.25rem 0.5rem !important;
                font-size: 0.7rem !important;
            }
            
            /* å›ºå®šè¼¸å…¥å€åŸŸé«˜åº¦ - é€²ä¸€æ­¥æ¸›å°‘ */
            .input-container {
                min-height: 60px !important;
                max-height: 60px !important;
                padding: 0.375rem !important;
            }
            
            /* è¨ˆç®—èŠå¤©å€åŸŸé«˜åº¦ï¼š100vh - header(38px) - mode toggle(36px) - input(60px) */
            .chat-area {
                height: calc(100vh - 38px - 36px - 60px) !important;
                height: calc(100dvh - 38px - 36px - 60px) !important;
                min-height: 0 !important;
                overflow-y: auto !important;
            }
            
            /* ç¢ºä¿ textarea åœ¨è¼¸å…¥å®¹å™¨å…§æ­£ç¢ºé¡¯ç¤º */
            .input-container textarea {
                max-height: 2.5rem !important;
                padding-top: 0.375rem !important;
                padding-bottom: 0.375rem !important;
                font-size: 0.8rem !important;
                line-height: 1.3 !important;
            }
            
            /* ç¢ºä¿ä¸»å®¹å™¨ä½¿ç”¨æ­£ç¢ºçš„é«˜åº¦ */
            .flex.flex-col.h-screen {
                height: 100vh !important;
                height: 100dvh !important;
                width: 100% !important;
                max-width: 100% !important;
                overflow: hidden !important;
                position: relative !important;
            }
            
            /* é˜²æ­¢æ°´å¹³æ»¾å‹• */
            * {
                max-width: 100%;
                box-sizing: border-box;
            }
            
            /* é˜²æ­¢å½ˆæ€§æ»¾å‹• */
            body, html {
                overscroll-behavior-y: none !important;
                overscroll-behavior-x: none !important;
                -webkit-overflow-scrolling: touch;
            }
        }
        
        @media (min-width: 641px) and (max-width: 1024px) {
            /* å¹³æ¿å„ªåŒ– */
            body {
                font-size: 15px;
            }
        }
        
        @media (min-width: 1025px) {
            /* æ¡Œé¢å„ªåŒ– */
            body {
                font-size: 16px;
            }
        }
        
        /* è§¸æ§è¨­å‚™å„ªåŒ– */
        @media (hover: none) and (pointer: coarse) {
            button, a {
                min-height: 44px;
                min-width: 44px;
            }
        }
        
        /* ç¢ºä¿ flexbox å®¹å™¨æ­£ç¢ºè™•ç†é«˜åº¦ */
        .flex-col {
            display: flex;
            flex-direction: column;
        }
        
        /* é˜²æ­¢å…§å®¹æº¢å‡º */
        .overflow-hidden {
            overflow: hidden;
        }
        
        .min-h-0 {
            min-height: 0;
        }
        
        /* 3D æœªä¾†æ„Ÿæ¨£å¼ */
        .futuristic-glow {
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3),
                        0 0 40px rgba(251, 191, 36, 0.2),
                        0 0 60px rgba(251, 191, 36, 0.1);
        }
        
        .futuristic-border {
            border: 1px solid rgba(251, 191, 36, 0.3);
            box-shadow: inset 0 0 10px rgba(251, 191, 36, 0.1);
        }
        
        .message-3d {
            transform-style: preserve-3d;
            transition: transform 0.3s ease;
        }
        
        .message-3d:hover {
            transform: translateZ(10px) scale(1.02);
        }
        
        /* 3D Canvas å®¹å™¨ */
        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        
        /* ç™¼å…‰å‹•ç•« */
        @keyframes glow-pulse {
            0%, 100% {
                opacity: 0.5;
                filter: brightness(1);
            }
            50% {
                opacity: 1;
                filter: brightness(1.5);
            }
        }
        
        .glow-animate {
            animation: glow-pulse 3s ease-in-out infinite;
        }
        
        /* 3D æ–‡å­—æ•ˆæœ */
        .text-3d {
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5),
                         0 0 20px rgba(251, 191, 36, 0.3),
                         0 0 30px rgba(251, 191, 36, 0.2);
        }
        
        /* æ–‡å­—æƒå…‰æ•ˆæœï¼ˆæŒ‰ç…§æ‚¨æä¾›çš„ä»£ç¢¼ï¼‰ */
        @keyframes shine {
            to { background-position: 200% center; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // =========================================================================
        // è¨­å®šå€åŸŸ (Configuration)
        // =========================================================================
        // ä½¿ç”¨å¾Œç«¯ä»£ç† APIï¼ˆAPI Key å®‰å…¨ä¿è­·åœ¨ä¼ºæœå™¨ç«¯ï¼‰
        // åœ¨ Vercel ä¸Šï¼Œä½¿ç”¨ç›¸å°è·¯å¾‘è‡ªå‹•æŒ‡å‘åŒåŸŸçš„ API
        // æœ¬åœ°é–‹ç™¼æ™‚ï¼Œå¯ä»¥è¨­å®š API_BASE_URL æŒ‡å‘æœ¬åœ°ä¼ºæœå™¨
        const API_BASE_URL = window.API_BASE_URL || ''; // ä¾‹å¦‚: 'http://localhost:3000' æˆ–ç•™ç©ºä½¿ç”¨ç›¸å°è·¯å¾‘ï¼ˆVercelï¼‰
        const GOOGLE_API_KEY = window.GOOGLE_API_KEY || null; // åƒ…ç”¨æ–¼æœ¬åœ°é–‹ç™¼ï¼Œä¸å»ºè­°å…¬é–‹ä½¿ç”¨

        // =========================================================================
        // ç³»çµ±é‚è¼¯é–‹å§‹
        // =========================================================================

        const { useState, useEffect, useRef } = React;
        const THREE = window.THREE;
        
        const Icon = ({ name, size = 20, className = "" }) => {
            useEffect(() => { lucide.createIcons(); }, [name]);
            return <i data-lucide={name} className={className} style={{ width: size, height: size, display: 'inline-block' }}></i>;
        };

        // =========================================================================
        // 2D ç²’å­è–èª•æ¨¹èƒŒæ™¯ï¼ˆå‚™ç”¨æ–¹æ¡ˆï¼Œç¢ºä¿åœ¨æ‰€æœ‰è¨­å‚™ä¸Šéƒ½èƒ½é¡¯ç¤ºï¼‰
        // =========================================================================
        const ChristmasBackground2D = ({ containerRef }) => {
            const canvasRef = useRef(null);
            const animationIdRef = useRef(null);
            const snowflakesRef = useRef([]);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !containerRef?.current) return;
                
                const ctx = canvas.getContext('2d');
                let animationId = null;
                
                const updateCanvasSize = () => {
                    if (!containerRef?.current || !canvas) return;
                    const container = containerRef.current;
                    const rect = container.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    const width = rect.width;
                    const height = rect.height;
                    
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    ctx.scale(dpr, dpr);
                    
                    return { width, height };
                };
                
                // é›ªèŠ±é¡
                class Snowflake {
                    constructor(width, height) {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.size = Math.random() * 3 + 1;
                        this.speed = Math.random() * 2 + 0.5;
                        this.wind = (Math.random() - 0.5) * 0.5;
                        this.opacity = Math.random() * 0.5 + 0.5;
                    }
                    
                    update(width, height) {
                        this.y += this.speed;
                        this.x += this.wind;
                        
                        if (this.y > height) {
                            this.y = -10;
                            this.x = Math.random() * width;
                        }
                        if (this.x < 0) this.x = width;
                        if (this.x > width) this.x = 0;
                    }
                    
                    draw(ctx) {
                        ctx.save();
                        ctx.globalAlpha = this.opacity;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                
                // åˆå§‹åŒ–é›ªèŠ±
                const initSnowflakes = () => {
                    const { width, height } = updateCanvasSize();
                    if (!width || !height) return;
                    
                    snowflakesRef.current = [];
                    const count = 100;
                    for (let i = 0; i < count; i++) {
                        snowflakesRef.current.push(new Snowflake(width, height));
                    }
                };
                
                // ç¹ªè£½è–èª•æ¨¹ï¼ˆç°¡åŒ–ç‰ˆï¼‰
                const drawChristmasTree = (ctx, x, y, size) => {
                    ctx.save();
                    // æ¨¹å¹¹
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x - size * 0.1, y, size * 0.2, size * 0.3);
                    
                    // æ¨¹è‘‰ï¼ˆä¸‰è§’å½¢ï¼‰
                    ctx.fillStyle = '#228B22';
                    for (let i = 0; i < 3; i++) {
                        const layerSize = size * (1 - i * 0.3);
                        ctx.beginPath();
                        ctx.moveTo(x, y - size * 0.8 + i * size * 0.3);
                        ctx.lineTo(x - layerSize * 0.5, y - size * 0.3 + i * size * 0.3);
                        ctx.lineTo(x + layerSize * 0.5, y - size * 0.3 + i * size * 0.3);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // æ˜Ÿæ˜Ÿ
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(x, y - size * 0.9);
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                        const x1 = x + Math.cos(angle) * size * 0.15;
                        const y1 = y - size * 0.9 + Math.sin(angle) * size * 0.15;
                        ctx.lineTo(x1, y1);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                };
                
                // ç¹ªè£½æ˜Ÿæ˜Ÿ
                const drawStar = (ctx, x, y, size, opacity) => {
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                        const x1 = x + Math.cos(angle) * size;
                        const y1 = y + Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                };
                
                // ç²’å­é¡ï¼ˆç”¨æ–¼ç²’å­æ¨¹ï¼‰
                class Particle {
                    constructor(x, y, heightRatio) {
                        this.x = x;
                        this.y = y;
                        this.heightRatio = heightRatio; // 0 åˆ° 1ï¼Œè¡¨ç¤ºåœ¨æ¨¹ä¸­çš„é«˜åº¦
                        this.size = (0.15 - heightRatio * 0.1) * (0.8 + Math.random() * 0.4);
                        this.baseOpacity = 0.7 + Math.random() * 0.3;
                        this.phase = Math.random() * Math.PI * 2;
                        this.speed = 0.5 + Math.random() * 1.5;
                    }
                    
                    update() {
                        this.phase += 0.02;
                    }
                    
                    draw(ctx, centerX, centerY, treeHeight) {
                        ctx.save();
                        const opacity = this.baseOpacity + Math.sin(this.phase * this.speed) * 0.2;
                        ctx.globalAlpha = opacity;
                        
                        // é¡è‰²æ¼¸è®Šï¼šé ‚éƒ¨ç™½è‰²ï¼Œå‘ä¸‹æ¼¸è®Šåˆ°ç²‰ç´…è‰²
                        const whiteAmount = 1 - this.heightRatio * 0.6;
                        const pinkAmount = this.heightRatio * 0.8;
                        const r = Math.min(255, (whiteAmount + pinkAmount * 0.8) * 255);
                        const g = Math.min(255, (whiteAmount + pinkAmount * 0.3) * 255);
                        const b = Math.min(255, (whiteAmount + pinkAmount * 1.0) * 255);
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.8)`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                
                // å‰µå»ºç²’å­æ¨¹
                const createParticleTree = (centerX, centerY, treeHeight, treeWidth) => {
                    const particles = [];
                    const particleCount = 300;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const heightRatio = Math.random(); // 0 åˆ° 1
                        const radius = heightRatio * treeWidth;
                        const angle = Math.random() * Math.PI * 2;
                        
                        // ä¸­å¿ƒå¯†é›†ï¼Œå¤–åœç¨€ç–
                        const distance = Math.random() < 0.3 ? 
                            Math.random() * radius * 0.5 : 
                            radius * 0.5 + Math.random() * radius * 0.5;
                        
                        const x = centerX + Math.cos(angle) * distance;
                        const y = centerY - heightRatio * treeHeight;
                        
                        particles.push(new Particle(x, y, heightRatio));
                    }
                    
                    return particles;
                };
                
                let particleTree = null;
                let treeCenterX = 0;
                let treeCenterY = 0;
                
                // åˆå§‹åŒ–ç²’å­æ¨¹
                const initParticleTree = () => {
                    const { width, height } = updateCanvasSize();
                    if (!width || !height) return;
                    
                    treeCenterX = width * 0.5;
                    treeCenterY = height * 0.7;
                    particleTree = createParticleTree(treeCenterX, treeCenterY, height * 0.5, width * 0.3);
                };
                
                // å‹•ç•«å¾ªç’°
                const animate = () => {
                    const { width, height } = updateCanvasSize();
                    if (!width || !height) {
                        animationId = requestAnimationFrame(animate);
                        return;
                    }
                    
                    // æ·±é»‘è‰²èƒŒæ™¯
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, width, height);
                    
                    // ç¹ªè£½ç´°å°èƒŒæ™¯æ˜Ÿæ˜Ÿ
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    for (let i = 0; i < 200; i++) {
                        const x = (i * 37) % width;
                        const y = (i * 53) % height;
                        const size = Math.random() * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // æ›´æ–°å’Œç¹ªè£½ç²’å­æ¨¹
                    if (particleTree) {
                        particleTree.forEach(particle => {
                            particle.update();
                            particle.draw(ctx, treeCenterX, treeCenterY, height * 0.5);
                        });
                    }
                    
                    // é ‚éƒ¨ç™¼å…‰æ˜Ÿæ˜Ÿ
                    const time = Date.now() * 0.001;
                    const starSize = 8 + Math.sin(time * 2) * 2;
                    const starOpacity = 0.8 + Math.sin(time * 2) * 0.2;
                    ctx.save();
                    ctx.globalAlpha = starOpacity;
                    ctx.fillStyle = '#FFB6C1';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#FFB6C1';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                        const x = treeCenterX + Math.cos(angle) * starSize;
                        const y = treeCenterY - height * 0.5 + Math.sin(angle) * starSize;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    
                    // åº•éƒ¨ç™¼å…‰åœ“ç’°
                    const ringY = treeCenterY + height * 0.1;
                    for (let i = 0; i < 3; i++) {
                        const ringRadius = 30 + i * 15;
                        const ringOpacity = (0.3 - i * 0.1) * (0.8 + Math.sin(time * 1.5 + i) * 0.2);
                        ctx.save();
                        ctx.strokeStyle = `rgba(255, 105, 180, ${ringOpacity})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(treeCenterX, ringY, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    // ç¹ªè£½ "Merry Christmas!" æ–‡å­—
                    ctx.save();
                    ctx.fillStyle = '#FFB6C1';
                    ctx.font = `italic ${Math.min(24, width * 0.06)}px 'Noto Serif TC', serif`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FFB6C1';
                    const textX = width * 0.1;
                    const textY = height * 0.5;
                    ctx.fillText('Merry Christmas!', textX, textY);
                    ctx.restore();
                    
                    // æ›´æ–°å’Œç¹ªè£½é›ªèŠ±
                    snowflakesRef.current.forEach(snowflake => {
                        snowflake.update(width, height);
                        snowflake.draw(ctx);
                    });
                    
                    animationId = requestAnimationFrame(animate);
                };
                
                // åˆå§‹åŒ–
                setTimeout(() => {
                    initSnowflakes();
                    initParticleTree();
                    animate();
                }, 100);
                
                // è™•ç†çª—å£å¤§å°è®ŠåŒ–
                const handleResize = () => {
                    initSnowflakes();
                };
                window.addEventListener('resize', handleResize);
                
                // æ¸…ç†
                return () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                };
            }, [containerRef]);
            
            return (
                <canvas
                    ref={canvasRef}
                    className="absolute top-0 left-0 pointer-events-none"
                    style={{
                        zIndex: 0,
                        width: '100%',
                        height: '100%',
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        backgroundColor: '#000000' // æ·±é»‘è‰²èƒŒæ™¯
                    }}
                />
            );
        };

        // =========================================================================
        // 3D ç«‹é«”æ˜Ÿç©ºå®‡å®™ + è–èª•ç¯€å ´æ™¯ï¼ˆä½¿ç”¨åŸç”Ÿ Three.jsï¼‰
        // =========================================================================
        const FuturisticScene = ({ containerRef }) => {
            const canvasRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const animationIdRef = useRef(null);
            const starSystemsRef = useRef(null);
            const treeSystemRef = useRef(null);
            const [error, setError] = useState(null);
            const [threeLoaded, setThreeLoaded] = useState(false);
            
            useEffect(() => {
                let retryCount = 0;
                const maxRetries = 50; // æœ€å¤šå˜—è©¦ 5 ç§’
                
                // ç­‰å¾… Three.js è¼‰å…¥
                const checkThreeJS = () => {
                    if (window.THREE && window.THREE.Scene) {
                        console.log('âœ… Three.js å·²è¼‰å…¥');
                        setThreeLoaded(true);
                        setTimeout(initScene, 200); // ç¨å¾®å»¶é²ç¢ºä¿å®Œå…¨è¼‰å…¥
                        return;
                    }
                    
                    retryCount++;
                    if (retryCount < maxRetries) {
                        setTimeout(checkThreeJS, 100);
                    } else {
                        console.warn('âŒ Three.js è¼‰å…¥è¶…æ™‚ï¼Œä½¿ç”¨ 2D å‚™ç”¨èƒŒæ™¯');
                        setError('Three.js timeout');
                    }
                };
                
                const initScene = () => {
                    console.log('ğŸ¨ é–‹å§‹åˆå§‹åŒ– 3D å ´æ™¯...');
                    
                    // æª¢æŸ¥ Three.js æ˜¯å¦è¼‰å…¥
                    if (!window.THREE || !window.THREE.Scene) {
                        console.warn('Three.js æœªè¼‰å…¥ï¼Œä½¿ç”¨å‚™ç”¨ 2D èƒŒæ™¯');
                        setError('Three.js not loaded');
                        return;
                    }
                    
                    // ç­‰å¾…å®¹å™¨æº–å‚™å¥½
                    if (!canvasRef.current || !containerRef?.current) {
                        console.log('â³ ç­‰å¾…å®¹å™¨æº–å‚™...');
                        setTimeout(() => {
                            if (canvasRef.current && containerRef?.current) {
                                initScene(); // é‡æ–°å˜—è©¦åˆå§‹åŒ–
                            } else {
                                console.warn('å®¹å™¨æœªæº–å‚™å¥½');
                                setError('Container not ready');
                            }
                        }, 200);
                        return;
                    }
                    
                    const THREE = window.THREE;
                    
                    try {
                        const container = containerRef.current;
                        let width = container.clientWidth;
                        let height = container.clientHeight;
                        
                        console.log(`ğŸ“ å®¹å™¨å°ºå¯¸: ${width}x${height}`);
                        
                        // ç¢ºä¿æœ‰æœ‰æ•ˆçš„å°ºå¯¸
                        if (width === 0 || height === 0) {
                            width = window.innerWidth || 800;
                            height = window.innerHeight || 600;
                            console.log(`ğŸ“ ä½¿ç”¨çª—å£å°ºå¯¸: ${width}x${height}`);
                        }
                        
                        // å‰µå»ºå ´æ™¯
                        const scene = new THREE.Scene();
                        scene.background = new THREE.Color(0x000000); // æ·±é»‘è‰²èƒŒæ™¯
                        sceneRef.current = scene;
                        console.log('âœ… å ´æ™¯å‰µå»ºæˆåŠŸï¼ŒèƒŒæ™¯è‰²: é»‘è‰²');
                        
                        // å‰µå»ºç›¸æ©Ÿï¼ˆç¨å¾®æ‹‰é«˜ï¼ŒæŒ‰ç…§æ‚¨æä¾›çš„ä»£ç¢¼ï¼‰
                        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                        camera.position.set(0, 5, 10); // ç›¸æ©Ÿä½ç½®ç¨å¾®æ‹‰é«˜
                        cameraRef.current = camera;
                        console.log('âœ… ç›¸æ©Ÿå‰µå»ºæˆåŠŸï¼Œä½ç½®:', camera.position);
                        
                        // å‰µå»ºæ¸²æŸ“å™¨ï¼ˆç§»å‹•è¨­å‚™å„ªåŒ–ï¼‰
                        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        console.log(`ğŸ“± ç§»å‹•è¨­å‚™: ${isMobile}`);
                        
                        let renderer;
                        try {
                            // ç¢ºä¿ canvas å­˜åœ¨
                            if (!canvasRef.current) {
                                console.error('âŒ Canvas å…ƒç´ ä¸å­˜åœ¨');
                                setError('Canvas not found');
                                return;
                            }
                            
                            console.log('ğŸ¨ å‰µå»º WebGL æ¸²æŸ“å™¨ï¼Œcanvas:', canvasRef.current);
                            
                            renderer = new THREE.WebGLRenderer({ 
                                canvas: canvasRef.current,
                                alpha: false, // ä¸é€æ˜ï¼Œä½¿ç”¨æ·±è‰²èƒŒæ™¯
                                antialias: !isMobile,
                                powerPreference: "high-performance"
                            });
                            
                            renderer.setSize(width, height);
                            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isMobile ? 1.5 : 2));
                            renderer.setClearColor(0x000000, 1); // æ·±é»‘è‰²èƒŒæ™¯
                            rendererRef.current = renderer;
                            console.log('âœ… WebGL æ¸²æŸ“å™¨å‰µå»ºæˆåŠŸï¼Œå°ºå¯¸:', width, 'x', height);
                            
                            // ç«‹å³æ¸²æŸ“ä¸€æ¬¡æ¸¬è©¦
                            renderer.render(scene, camera);
                            console.log('âœ… æ¸¬è©¦æ¸²æŸ“å®Œæˆ');
                        } catch (e) {
                            console.error('âŒ WebGL æ¸²æŸ“å™¨å‰µå»ºå¤±æ•—:', e);
                            setError('WebGL not supported');
                            return;
                        }
                        
                        // ========== å‰µå»ºæ·±è‰²èƒŒæ™¯æ˜Ÿç©º ==========
                        console.log('âœ¨ å‰µå»ºèƒŒæ™¯æ˜Ÿç©º...');
                        
                        // ç´°å°çš„èƒŒæ™¯æ˜Ÿæ˜Ÿç²’å­ï¼ˆæ·±ç©ºæ„Ÿï¼‰
                        const backgroundStarCount = isMobile ? 500 : 1000;
                        const bgPositions = new Float32Array(backgroundStarCount * 3);
                        const bgColors = new Float32Array(backgroundStarCount * 3);
                        
                        for (let i = 0; i < backgroundStarCount; i++) {
                            const i3 = i * 3;
                            bgPositions[i3] = (Math.random() - 0.5) * 40;
                            bgPositions[i3 + 1] = (Math.random() - 0.5) * 40;
                            bgPositions[i3 + 2] = (Math.random() - 0.5) * 20 - 10;
                            
                            // éå¸¸æ·¡çš„ç™½è‰²æ˜Ÿæ˜Ÿ
                            const brightness = 0.3 + Math.random() * 0.3;
                            bgColors[i3] = brightness;
                            bgColors[i3 + 1] = brightness;
                            bgColors[i3 + 2] = brightness;
                        }
                        
                        const bgStarGeometry = new THREE.BufferGeometry();
                        bgStarGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
                        bgStarGeometry.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));
                        
                        const bgStarMaterial = new THREE.PointsMaterial({
                            size: 0.05,
                            vertexColors: true,
                            transparent: true,
                            opacity: 0.6,
                            sizeAttenuation: true
                        });
                        
                        const backgroundStars = new THREE.Points(bgStarGeometry, bgStarMaterial);
                        scene.add(backgroundStars);
                        
                        // ========== å‰µå»ºèºæ—‹ç²’å­è–èª•æ¨¹ï¼ˆä½¿ç”¨æ‚¨æä¾›çš„æ•¸å­¸å…¬å¼ï¼‰==========
                        console.log('ğŸ„ å‰µå»ºèºæ—‹ç²’å­è–èª•æ¨¹...');
                        
                        const particleCount = isMobile ? 5000 : 15000;
                        const positions = [];
                        const colors = [];
                        
                        // é¡è‰²å®šç¾©ï¼ˆéŠ€è‰²/ç™½è‰²/ç²‰è‰²ç³»ï¼Œç¬¦åˆåœ–ç‰‡é¢¨æ ¼ï¼‰
                        const color1 = new THREE.Color('#FFB6C1'); // æ·ºç²‰è‰²
                        const color2 = new THREE.Color('#FFD700'); // é‡‘è‰²
                        const color3 = new THREE.Color('#FFFFFF'); // ç™½è‰²
                        const color4 = new THREE.Color('#FF69B4'); // ç²‰ç´…è‰²
                        const color5 = new THREE.Color('#C0C0C0'); // éŠ€è‰²
                        
                        // --- æ ¸å¿ƒæ•¸å­¸é‚è¼¯ï¼šèºæ—‹åœ“éŒï¼ˆå®Œå…¨æŒ‰ç…§æ‚¨æä¾›çš„å…¬å¼ï¼‰---
                        for (let i = 0; i < particleCount; i++) {
                            // y: é«˜åº¦ï¼Œå¾ -5 åˆ° 5
                            const y = (Math.random() - 0.5) * 10;
                            
                            // radius: åŠå¾‘ã€‚é«˜åº¦è¶Šé«˜(yè¶Šå¤§)ï¼ŒåŠå¾‘è¶Šå°ã€‚
                            // æŠŠ y å¾ [-5, 5] æ˜ å°„åˆ° [5, 0] çš„åŠå¾‘ç¯„åœ
                            const radius = (5 - y) * 0.4;
                            
                            // angle: è§’åº¦ã€‚è®“ç²’å­æ—‹è½‰åˆ†ä½ˆï¼Œç”¢ç”Ÿèºæ—‹ç´‹ç†
                            const angle = i * 0.2 + y * 5.0; // y * 5.0 ç”¢ç”Ÿèºæ—‹æ•ˆæœ
                            
                            // åŠ ä¸Šä¸€é»éš¨æ©Ÿæ€§ï¼Œä¸è®“æ¨¹å¤ªæ­»æ¿
                            const randomR = radius + (Math.random() - 0.5) * 0.5;
                            
                            const x = Math.cos(angle) * randomR;
                            const z = Math.sin(angle) * randomR;
                            
                            positions.push(x, y, z);
                            
                            // é¡è‰²åˆ†é…ï¼šé ‚éƒ¨ç™½è‰²/éŠ€è‰²ï¼Œå‘ä¸‹æ¼¸è®Šåˆ°ç²‰è‰²/é‡‘è‰²ï¼ˆç¬¦åˆåœ–ç‰‡é¢¨æ ¼ï¼‰
                            const heightRatio = (y + 5) / 10; // 0 åˆ° 1
                            const rand = Math.random();
                            
                            if (heightRatio > 0.75) {
                                // é ‚éƒ¨ï¼šä¸»è¦æ˜¯ç™½è‰²å’ŒéŠ€è‰²
                                if (rand < 0.7) {
                                    colors.push(color3.r, color3.g, color3.b); // ç™½è‰²
                                } else {
                                    colors.push(color5.r, color5.g, color5.b); // éŠ€è‰²
                                }
                            } else if (heightRatio > 0.5) {
                                // ä¸­ä¸Šéƒ¨ï¼šç™½è‰²å’Œæ·ºç²‰è‰²æ··åˆ
                                if (rand < 0.5) {
                                    colors.push(color3.r, color3.g, color3.b); // ç™½è‰²
                                } else {
                                    colors.push(color1.r, color1.g, color1.b); // æ·ºç²‰è‰²
                                }
                            } else if (heightRatio > 0.25) {
                                // ä¸­ä¸‹éƒ¨ï¼šç²‰è‰²ç‚ºä¸»
                                if (rand < 0.7) {
                                    colors.push(color4.r, color4.g, color4.b); // ç²‰ç´…è‰²
                                } else {
                                    colors.push(color1.r, color1.g, color1.b); // æ·ºç²‰è‰²
                                }
                            } else {
                                // åº•éƒ¨ï¼šç²‰è‰²å’Œé‡‘è‰²
                                if (rand < 0.6) {
                                    colors.push(color4.r, color4.g, color4.b); // ç²‰ç´…è‰²
                                } else {
                                    colors.push(color2.r, color2.g, color2.b); // é‡‘è‰²
                                }
                            }
                        }
                        
                        const treeGeometry = new THREE.BufferGeometry();
                        treeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        treeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        
                        const treeMaterial = new THREE.PointsMaterial({
                            size: 0.15,
                            vertexColors: true,
                            blending: THREE.AdditiveBlending, // ç™¼å…‰ç–ŠåŠ æ¨¡å¼ï¼ˆé—œéµï¼ï¼‰
                            depthWrite: false,
                            transparent: true,
                            opacity: 0.8,
                            sizeAttenuation: true
                        });
                        
                        const particleTree = new THREE.Points(treeGeometry, treeMaterial);
                        particleTree.position.set(0, 0, -5);
                        scene.add(particleTree);
                        console.log('âœ… èºæ—‹ç²’å­æ¨¹å·²å‰µå»ºï¼Œç²’å­æ•¸:', particleCount);
                        
                        // é ‚éƒ¨ç™¼å…‰æ˜Ÿæ˜Ÿï¼ˆæ¨¹é ‚ï¼‰
                        const topStarGeo = new THREE.OctahedronGeometry(0.3, 0);
                        const topStarMat = new THREE.MeshBasicMaterial({
                            color: 0xFFB6C1,
                            transparent: true,
                            opacity: 0.9
                        });
                        const topStar = new THREE.Mesh(topStarGeo, topStarMat);
                        topStar.position.set(0, 5.2, -5);
                        topStar.rotation.z = Math.PI / 4;
                        scene.add(topStar);
                        
                        // æ·»åŠ åº•éƒ¨çš„å…‰ç’°ï¼ˆå®Œå…¨æŒ‰ç…§æ‚¨æä¾›çš„ä»£ç¢¼ï¼‰
                        const ringGeo = new THREE.TorusGeometry(2.0, 0.05, 16, 100);
                        const ringMat = new THREE.MeshBasicMaterial({ 
                            color: 0xFF69B4,
                            transparent: true,
                            opacity: 0.6
                        });
                        const ring = new THREE.Mesh(ringGeo, ringMat);
                        ring.rotation.x = -Math.PI / 2;
                        ring.position.set(0, -5, -5);
                        scene.add(ring);
                        console.log('âœ… åº•éƒ¨å…‰ç’°å·²å‰µå»º');
                        
                        // å­˜å„²ç”¨æ–¼å‹•ç•«
                        starSystemsRef.current = [{ stars: backgroundStars, geometry: bgStarGeometry }];
                        treeSystemRef.current = { 
                            tree: particleTree, 
                            geometry: treeGeometry,
                            topStar: topStar,
                            ring: ring
                        };
                        
                        const starSystems = starSystemsRef.current;
                        const treeSystem = treeSystemRef.current;
                    
                        // ========== å‰µå»ºå…‰æºç³»çµ± ==========
                        console.log('ğŸ’¡ å‰µå»ºå…‰æºç³»çµ±...');
                        
                        // æ·»åŠ éœ§æ°£æ•ˆæœï¼Œè®“é è™•çš„ç²’å­è®Šæš—ï¼Œæ›´æœ‰å±¤æ¬¡æ„Ÿ
                        scene.fog = new THREE.FogExp2(0x000000, 0.05);
                        
                        // ç’°å¢ƒå…‰ï¼ˆå¾ˆæš—ï¼Œä¸»è¦é ç²’å­è‡ªèº«ç™¼å…‰ï¼‰
                        const ambientLight = new THREE.AmbientLight(0x000000, 0.1);
                        scene.add(ambientLight);
                        
                        // é»å…‰æºï¼ˆç…§äº®ç²’å­æ¨¹ï¼‰
                        const pointLight = new THREE.PointLight(0xFFB6C1, 1.0, 50);
                        pointLight.position.set(0, 0, -4);
                        scene.add(pointLight);
                    
                        // ========== å‹•ç•«å¾ªç’° ==========
                        console.log('ğŸ¬ å•Ÿå‹•å‹•ç•«å¾ªç’°...');
                        const clock = new THREE.Clock();
                        
                        const animate = () => {
                            animationIdRef.current = requestAnimationFrame(animate);
                            const elapsedTime = clock.getElapsedTime();
                            
                            // 1. èƒŒæ™¯æ˜Ÿæ˜Ÿç·©æ…¢æ—‹è½‰
                            backgroundStars.rotation.y = elapsedTime * 0.05;
                            
                            // 2. è®“æ•´æ£µæ¨¹æ—‹è½‰ï¼ˆæŒ‰ç…§æ‚¨æä¾›çš„ä»£ç¢¼ï¼‰
                            if (treeSystem && treeSystem.tree) {
                                treeSystem.tree.rotation.y = elapsedTime * 0.3;
                            }
                            
                            // 3. é ‚éƒ¨æ˜Ÿæ˜Ÿæ—‹è½‰
                            if (treeSystem && treeSystem.topStar) {
                                treeSystem.topStar.rotation.y = elapsedTime * 0.5;
                                treeSystem.topStar.rotation.x = elapsedTime * 0.3;
                            }
                            
                            // 4. åº•éƒ¨å…‰ç’°è„ˆè¡å¼ç¸®æ”¾ï¼ˆæŒ‰ç…§æ‚¨æä¾›çš„ä»£ç¢¼ï¼‰
                            if (treeSystem && treeSystem.ring) {
                                const scale = 1 + Math.sin(elapsedTime * 2) * 0.1;
                                treeSystem.ring.scale.set(scale, scale, scale);
                            }
                            
                            // 5. ç›¸æ©Ÿè¼•å¾®ç§»å‹•ï¼ˆå‰µé€ æ²‰æµ¸æ„Ÿï¼‰
                            camera.position.x = Math.sin(elapsedTime * 0.1) * 0.3;
                            camera.position.y = 5 + Math.cos(elapsedTime * 0.08) * 0.2;
                            camera.lookAt(0, 0, -5);
                            
                            renderer.render(scene, camera);
                        };
                        animate();
                        console.log('âœ… å ´æ™¯åˆå§‹åŒ–å®Œæˆï¼å‹•ç•«å¾ªç’°å·²å•Ÿå‹•');
                        console.log('ğŸ“Š å ´æ™¯çµ±è¨ˆ:', {
                            objects: scene.children.length,
                            backgroundStars: backgroundStars ? 'å·²å‰µå»º' : 'æœªå‰µå»º',
                            particleTree: particleTree ? 'å·²å‰µå»º' : 'æœªå‰µå»º',
                            topStar: topStar ? 'å·²å‰µå»º' : 'æœªå‰µå»º',
                            ring: ring ? 'å·²å‰µå»º' : 'æœªå‰µå»º'
                        });
                        
                        // ç«‹å³æ¸²æŸ“ä¸€æ¬¡ç¢ºä¿å¯è¦‹
                        setTimeout(() => {
                            if (renderer && scene && camera) {
                                renderer.render(scene, camera);
                                console.log('âœ… åˆå§‹æ¸²æŸ“å®Œæˆ');
                            } else {
                                console.error('âŒ æ¸²æŸ“å™¨ã€å ´æ™¯æˆ–ç›¸æ©Ÿä¸å­˜åœ¨');
                            }
                        }, 100);
                    
                    // è™•ç†çª—å£å¤§å°è®ŠåŒ–
                    const handleResize = () => {
                        if (!containerRef?.current || !camera || !renderer) return;
                        const newWidth = containerRef.current.clientWidth || window.innerWidth;
                        const newHeight = containerRef.current.clientHeight || window.innerHeight;
                        if (newWidth > 0 && newHeight > 0) {
                            camera.aspect = newWidth / newHeight;
                            camera.updateProjectionMatrix();
                            renderer.setSize(newWidth, newHeight);
                        }
                    };
                    
                    window.addEventListener('resize', handleResize);
                    
                    // æ¸…ç†å‡½æ•¸
                    return () => {
                        if (animationIdRef.current) {
                            cancelAnimationFrame(animationIdRef.current);
                        }
                        window.removeEventListener('resize', handleResize);
                        // æ¸…ç†æ‰€æœ‰è³‡æº
                        if (starSystemsRef.current) {
                            starSystemsRef.current.forEach(system => {
                                if (system.geometry) system.geometry.dispose();
                                if (system.material) system.material.dispose();
                            });
                        }
                        if (treeSystemRef.current) {
                            const treeSystem = treeSystemRef.current;
                            if (treeSystem.geometry) treeSystem.geometry.dispose();
                            if (treeMaterial) treeMaterial.dispose();
                            if (treeSystem.topStar) {
                                treeSystem.topStar.traverse(child => {
                                    if (child.geometry) child.geometry.dispose();
                                    if (child.material) child.material.dispose();
                                });
                            }
                            if (treeSystem.ring) {
                                if (treeSystem.ring.geometry) treeSystem.ring.geometry.dispose();
                                if (treeSystem.ring.material) treeSystem.ring.material.dispose();
                            }
                        }
                        if (rendererRef.current) rendererRef.current.dispose();
                    };
                    } catch (err) {
                        console.error('âŒ 3D å ´æ™¯åˆå§‹åŒ–éŒ¯èª¤:', err);
                        setError(err.message);
                    }
                };
                
                // é–‹å§‹æª¢æŸ¥
                checkThreeJS();
            }, [containerRef]);
            
            // å¦‚æœæœ‰éŒ¯èª¤ï¼Œä¸é¡¯ç¤º 3D canvasï¼Œè®“ 2D èƒŒæ™¯é¡¯ç¤º
            if (error) {
                console.log('âš ï¸ 3D å ´æ™¯éŒ¯èª¤ï¼Œä½¿ç”¨ 2D å‚™ç”¨èƒŒæ™¯');
                return null;
            }
            
            // å¦‚æœæœ‰éŒ¯èª¤ï¼Œä¸é¡¯ç¤º 3D canvasï¼Œè®“ 2D èƒŒæ™¯é¡¯ç¤º
            if (error) {
                console.log('âš ï¸ 3D å ´æ™¯éŒ¯èª¤ï¼Œä½¿ç”¨ 2D å‚™ç”¨èƒŒæ™¯');
                return null;
            }
            
            return (
                <canvas
                    ref={canvasRef}
                    className="absolute top-0 left-0 pointer-events-none"
                    style={{
                        zIndex: 1, // 3D åœ¨ 2D ä¹‹ä¸Š
                        width: '100%',
                        height: '100%',
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        backgroundColor: '#000000', // æ·±é»‘è‰²èƒŒæ™¯
                        display: 'block'
                    }}
                />
            );
        };

        // =========================================================================
        // èˆŠçš„ 2D ç²’å­èƒŒæ™¯ç³»çµ±ï¼ˆä¿ç•™ä½œç‚ºå‚™ç”¨ï¼‰
        // =========================================================================
        const ParticleBackground = ({ containerRef }) => {
            const canvasRef = useRef(null);
            const animationFrameRef = useRef(null);
            const particlesRef = useRef([]);
            const isVisibleRef = useRef(true);
            const resizeObserverRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !containerRef?.current) return;

                const ctx = canvas.getContext('2d');
                let animationId = null;

                // æª¢æ¸¬è¨­å‚™æ€§èƒ½
                const isLowEndDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                    || (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2);
                
                // æ ¹æ“šè¨­å‚™æ€§èƒ½èª¿æ•´ç²’å­æ•¸é‡
                const particleCount = isLowEndDevice ? 15 : 25;

                // ç²’å­é¡
                class Particle {
                    constructor(width, height) {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.size = Math.random() * 2 + 1;
                        this.speedX = (Math.random() - 0.5) * 0.3;
                        this.speedY = (Math.random() - 0.5) * 0.3;
                        this.opacity = Math.random() * 0.3 + 0.1; // ä½é€æ˜åº¦ï¼Œä¸å¹²æ“¾é–±è®€
                        this.hue = 35 + Math.random() * 20; // é‡‘è‰²/ç¥ç€è‰²ç¯„åœ (35-55)
                        this.angle = Math.random() * Math.PI * 2;
                        this.radius = Math.random() * 50 + 20;
                    }

                    update(width, height) {
                        // ç·©æ…¢çš„åœ“å‘¨é‹å‹•
                        this.angle += 0.002;
                        this.x += Math.cos(this.angle) * 0.2 + this.speedX;
                        this.y += Math.sin(this.angle) * 0.2 + this.speedY;

                        // é‚Šç•Œè™•ç†
                        if (this.x < 0 || this.x > width) this.speedX *= -1;
                        if (this.y < 0 || this.y > height) this.speedY *= -1;

                        // ä¿æŒåœ¨ç•«å¸ƒå…§
                        this.x = Math.max(0, Math.min(width, this.x));
                        this.y = Math.max(0, Math.min(height, this.y));
                    }

                    draw(ctx) {
                        ctx.save();
                        ctx.globalAlpha = this.opacity;
                        
                        // ç¹ªè£½ç™¼å…‰ç²’å­
                        const gradient = ctx.createRadialGradient(
                            this.x, this.y, 0,
                            this.x, this.y, this.size * 2
                        );
                        gradient.addColorStop(0, `hsla(${this.hue}, 70%, 60%, 1)`);
                        gradient.addColorStop(0.5, `hsla(${this.hue}, 70%, 60%, 0.5)`);
                        gradient.addColorStop(1, `hsla(${this.hue}, 70%, 60%, 0)`);
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }

                // æ›´æ–° Canvas å°ºå¯¸
                const updateCanvasSize = () => {
                    if (!containerRef?.current || !canvas) return;
                    
                    const container = containerRef.current;
                    const rect = container.getBoundingClientRect();
                    
                    // ä½¿ç”¨å¯¦éš›åƒç´ å°ºå¯¸ï¼Œç¢ºä¿é«˜ DPI é¡¯ç¤ºæ­£ç¢º
                    const dpr = window.devicePixelRatio || 1;
                    const width = rect.width;
                    const height = rect.height;
                    
                    // è¨­ç½® Canvas çš„é¡¯ç¤ºå°ºå¯¸
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    
                    // è¨­ç½® Canvas çš„å¯¦éš›åƒç´ å°ºå¯¸ï¼ˆè€ƒæ…® DPRï¼‰
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    
                    // ç¸®æ”¾ç¹ªåœ–ä¸Šä¸‹æ–‡ä»¥åŒ¹é… DPR
                    ctx.scale(dpr, dpr);
                    
                    return { width, height };
                };

                // åˆå§‹åŒ–ç²’å­
                const initParticles = () => {
                    const { width, height } = updateCanvasSize();
                    if (!width || !height) return;
                    
                    particlesRef.current = [];
                    for (let i = 0; i < particleCount; i++) {
                        particlesRef.current.push(new Particle(width, height));
                    }
                };

                // ç¹ªè£½é€£æ¥ç·šï¼ˆå¯é¸ï¼Œæ›´å¾®å¦™çš„è¦–è¦ºæ•ˆæœï¼‰
                const drawConnections = (width, height) => {
                    const particles = particlesRef.current;
                    for (let i = 0; i < particles.length; i++) {
                        for (let j = i + 1; j < particles.length; j++) {
                            const dx = particles[i].x - particles[j].x;
                            const dy = particles[i].y - particles[j].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < 120) {
                                ctx.save();
                                ctx.globalAlpha = (120 - distance) / 120 * 0.1; // éå¸¸ä½çš„é€æ˜åº¦
                                ctx.strokeStyle = `hsl(35, 70%, 60%)`;
                                ctx.lineWidth = 0.5;
                                ctx.beginPath();
                                ctx.moveTo(particles[i].x, particles[i].y);
                                ctx.lineTo(particles[j].x, particles[j].y);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                    }
                };

                // å‹•ç•«å¾ªç’°
                const animate = () => {
                    if (!isVisibleRef.current) {
                        animationId = requestAnimationFrame(animate);
                        return;
                    }

                    const { width, height } = updateCanvasSize();
                    if (!width || !height || particlesRef.current.length === 0) {
                        animationId = requestAnimationFrame(animate);
                        return;
                    }

                    // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡æ–°åˆå§‹åŒ–ç²’å­ï¼ˆå°ºå¯¸è®ŠåŒ–ï¼‰
                    const firstParticle = particlesRef.current[0];
                    if (firstParticle && (firstParticle.x > width || firstParticle.y > height)) {
                        initParticles();
                    }

                    // æ¸…é™¤ç•«å¸ƒï¼ˆä½¿ç”¨åŠé€æ˜ä»¥å¯¦ç¾æ‹–å°¾æ•ˆæœï¼‰
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, width, height);

                    // æ›´æ–°å’Œç¹ªè£½ç²’å­
                    particlesRef.current.forEach(particle => {
                        particle.update(width, height);
                        particle.draw(ctx);
                    });

                    // ç¹ªè£½é€£æ¥ç·šï¼ˆå¯é¸ï¼‰
                    drawConnections(width, height);

                    animationId = requestAnimationFrame(animate);
                };

                // è™•ç†çª—å£å¤§å°è®ŠåŒ–
                const handleResize = () => {
                    initParticles();
                };

                // è™•ç†é é¢å¯è¦‹æ€§ï¼ˆç¯€çœæ€§èƒ½ï¼‰
                const handleVisibilityChange = () => {
                    isVisibleRef.current = !document.hidden;
                };

                // ä½¿ç”¨ ResizeObserver ç›£è½å®¹å™¨å°ºå¯¸è®ŠåŒ–
                if (containerRef?.current && window.ResizeObserver) {
                    resizeObserverRef.current = new ResizeObserver(() => {
                        initParticles();
                    });
                    resizeObserverRef.current.observe(containerRef.current);
                }

                // åˆå§‹åŒ–
                setTimeout(() => {
                    initParticles();
                    animate();
                }, 100); // ç¨å¾®å»¶é²ç¢ºä¿å®¹å™¨å·²æ¸²æŸ“

                // ç›£è½äº‹ä»¶
                window.addEventListener('resize', handleResize);
                document.addEventListener('visibilitychange', handleVisibilityChange);

                // æ¸…ç†å‡½æ•¸
                return () => {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    if (resizeObserverRef.current) {
                        resizeObserverRef.current.disconnect();
                    }
                    window.removeEventListener('resize', handleResize);
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                };
            }, [containerRef]);

            return (
                <canvas
                    ref={canvasRef}
                    className="absolute top-0 left-0 pointer-events-none"
                    style={{
                        zIndex: 0,
                        opacity: 0.4, // é™ä½é€æ˜åº¦ï¼Œç¢ºä¿ä¸å¹²æ“¾å…§å®¹
                        width: '100%',
                        height: '100%',
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0
                    }}
                />
            );
        };

        const SYSTEM_PROMPT_BIBLE_ONLY = `
You are a wise, loving, and learned Christian AI Pastor.
Your task is to provide spiritual guidance and answers based on the user's questions.

**IMPORTANT: You can answer ANY type of question, including:**
- Personal life problems (relationships, work, family, finances, health, etc.)
- Spiritual questions and biblical interpretation
- Ethical dilemmas and moral questions
- Life decisions and guidance
- Emotional struggles and challenges
- Any question where the user seeks biblical wisdom

**Strict Rules:**

1. **Sola Scriptura:** Your answers must be *completely* based on the Old Testament and New Testament. Do not cite external secular views unless they fully align with biblical truth.

2. **Citation Required:** Every point or answer you make *must* cite specific Bible verses. Format example: (John 3:16) or (Genesis 1:1).

3. **Explanation and Application:** After citing verses, explain how the verse answers the user's question. For personal life problems, show how biblical principles apply to their specific situation.

4. **Active Guidance and Questioning (CRITICAL):** You MUST actively guide users to express their problems more clearly. Don't just answer the surface question - dig deeper to understand their real concerns.
   - Ask follow-up questions to clarify: "èƒ½å¤šå‘Šè¨´æˆ‘ä¸€äº›ç´°ç¯€å—ï¼Ÿ" or "What specific situation are you facing?"
   - Probe gently: "è½èµ·ä¾†ä½ å¯èƒ½æœ‰æ›´æ·±å±¤çš„å›°æ“¾ï¼Œé¡˜æ„å¤šåˆ†äº«ä¸€äº›å—ï¼Ÿ" or "It sounds like there might be more to this. Can you tell me more?"
   - Show genuine interest: "æˆ‘æƒ³æ›´äº†è§£ä½ çš„æƒ…æ³ï¼Œé€™æ¨£æ‰èƒ½çµ¦ä½ æœ€é©åˆçš„å»ºè­°ã€‚" or "I'd like to understand your situation better so I can give you the most helpful guidance."
   - Guide users to express emotions: "ä½ ç¾åœ¨çš„æ„Ÿå—æ˜¯ä»€éº¼ï¼Ÿ" or "How are you feeling about this?"
   - Help identify root causes: "ä½ è¦ºå¾—é€™å€‹å•é¡Œçš„æ ¹æœ¬åŸå› æ˜¯ä»€éº¼ï¼Ÿ" or "What do you think is the root cause of this issue?"
   - Be like a caring friend who wants to truly understand, not just give quick answers.

5. **Tone (CRITICAL):** Respond in a relaxed, friendly, and humorous way, like chatting with a close friend. Be warm, approachable, and conversational. Use natural language, occasional light humor (when appropriate), and make the conversation feel like you're talking to a friend over coffee. Avoid being overly formal, preachy, or academic. Be genuine, relatable, and easy-going while still being respectful and encouraging.

5. **Language Matching (CRITICAL):** You MUST respond in the EXACT same language as the user's question. This is MANDATORY and non-negotiable.
   - If the user asks in English, you MUST respond entirely in English.
   - If the user asks in Chinese (Traditional or Simplified), you MUST respond entirely in Traditional Chinese.
   - If the user asks in Japanese, you MUST respond entirely in Japanese.
   - If the user asks in Korean, you MUST respond entirely in Korean.
   - If the user asks in Spanish, you MUST respond entirely in Spanish.
   - If the user asks in French, you MUST respond entirely in French.
   - If the user asks in any other language, you MUST respond in that same language.
   - DO NOT mix languages. DO NOT translate the user's question to another language. Use the EXACT language the user used.

6. **Version:** Default to CUV (Chinese Union Version) wording for Chinese responses.
`;

        const SYSTEM_PROMPT_WEB_SEARCH = `
You are a wise, up-to-date Christian AI Pastor.
Your task is to answer the user's questions, combining biblical truth with broad knowledge.

**IMPORTANT: You can answer ANY type of question, including:**
- Personal life problems (relationships, work, family, finances, health, etc.)
- Spiritual questions and biblical interpretation
- Ethical dilemmas and moral questions
- Life decisions and guidance
- Emotional struggles and challenges
- Any question where the user seeks biblical wisdom combined with practical resources

**Rules:**

1. **Core Foundation:** Your answers must be rooted in the Old Testament and New Testament.

2. **Scripture Citation:** When you mention biblical principles, *must* cite specific chapters and verses (book chapter:verse).

3. **Broad Knowledge:** You can use search tools to find historical background, original Greek/Hebrew analysis, views of famous theologians, modern social data, Christian counseling resources, and practical advice from Christian sources to enrich your answers.

4. **Analysis:** Compare and analyze information from the web with biblical truth. For personal life problems, combine biblical principles with practical Christian resources and guidance.

5. **Active Guidance and Questioning (CRITICAL):** You MUST actively guide users to express their problems more clearly. Don't just answer the surface question - dig deeper to understand their real concerns.
   - Ask follow-up questions to clarify: "èƒ½å¤šå‘Šè¨´æˆ‘ä¸€äº›ç´°ç¯€å—ï¼Ÿ" or "What specific situation are you facing?"
   - Probe gently: "è½èµ·ä¾†ä½ å¯èƒ½æœ‰æ›´æ·±å±¤çš„å›°æ“¾ï¼Œé¡˜æ„å¤šåˆ†äº«ä¸€äº›å—ï¼Ÿ" or "It sounds like there might be more to this. Can you tell me more?"
   - Show genuine interest: "æˆ‘æƒ³æ›´äº†è§£ä½ çš„æƒ…æ³ï¼Œé€™æ¨£æ‰èƒ½çµ¦ä½ æœ€é©åˆçš„å»ºè­°ã€‚" or "I'd like to understand your situation better so I can give you the most helpful guidance."
   - Guide users to express emotions: "ä½ ç¾åœ¨çš„æ„Ÿå—æ˜¯ä»€éº¼ï¼Ÿ" or "How are you feeling about this?"
   - Help identify root causes: "ä½ è¦ºå¾—é€™å€‹å•é¡Œçš„æ ¹æœ¬åŸå› æ˜¯ä»€éº¼ï¼Ÿ" or "What do you think is the root cause of this issue?"
   - Be like a caring friend who wants to truly understand, not just give quick answers.

6. **Tone (CRITICAL):** Respond in a relaxed, friendly, and humorous way, like chatting with a close friend. Be warm, approachable, and conversational. Use natural language, occasional light humor (when appropriate), and make the conversation feel like you're talking to a friend over coffee. Avoid being overly formal, preachy, or academic. Be genuine, relatable, and easy-going while still being respectful, insightful, and encouraging.

6. **Language Matching (CRITICAL):** You MUST respond in the EXACT same language as the user's question. This is MANDATORY and non-negotiable.
   - If the user asks in English, you MUST respond entirely in English.
   - If the user asks in Chinese (Traditional or Simplified), you MUST respond entirely in Traditional Chinese.
   - If the user asks in Japanese, you MUST respond entirely in Japanese.
   - If the user asks in Korean, you MUST respond entirely in Korean.
   - If the user asks in Spanish, you MUST respond entirely in Spanish.
   - If the user asks in French, you MUST respond entirely in French.
   - If the user asks in any other language, you MUST respond in that same language.
   - DO NOT mix languages. DO NOT translate the user's question to another language. Use the EXACT language the user used.
   - All citations, explanations, and disclaimers MUST be in the same language as the user's question.
`;

        const callGeminiAPI = async (prompt, history, mode) => {
            // å„ªå…ˆä½¿ç”¨å¾Œç«¯ä»£ç† APIï¼ˆå®‰å…¨ï¼‰
            // å¦‚æœè¨­å®šäº† API_BASE_URLï¼Œä½¿ç”¨å®ƒï¼›å¦å‰‡ä½¿ç”¨ç›¸å°è·¯å¾‘ï¼ˆé©ç”¨æ–¼ Vercelï¼‰
            const apiUrl = API_BASE_URL ? `${API_BASE_URL}/api/chat` : '/api/chat';
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt, history, mode })
                });

                if (!response.ok) {
                    const errData = await response.json().catch(() => ({}));
                    throw new Error(errData.error || `ä¼ºæœå™¨éŒ¯èª¤: ${response.status}`);
                }

                const data = await response.json();
                return { text: data.text, grounding: data.grounding || [] };
            } catch (error) {
                // å¦‚æœå¾Œç«¯ API å¤±æ•—ä¸”æ²’æœ‰è¨­å®š API_BASE_URLï¼Œå˜—è©¦é™ç´šåˆ°ç›´æ¥ API èª¿ç”¨
                if (!API_BASE_URL && GOOGLE_API_KEY) {
                    console.warn('å¾Œç«¯ API å¤±æ•—ï¼Œå˜—è©¦ç›´æ¥èª¿ç”¨...');
                    // ç¹¼çºŒåŸ·è¡Œä¸‹é¢çš„ç›´æ¥ API èª¿ç”¨é‚è¼¯
                } else {
                    throw new Error(`å¾Œç«¯ API éŒ¯èª¤: ${error.message}`);
                }
            }

            // é™ç´šæ–¹æ¡ˆï¼šç›´æ¥å‘¼å« Google APIï¼ˆåƒ…ç”¨æ–¼æœ¬åœ°é–‹ç™¼ï¼Œä¸å»ºè­°å…¬é–‹ï¼‰
            if (!GOOGLE_API_KEY || GOOGLE_API_KEY.includes("åœ¨æ­¤è™•è²¼ä¸Š") || GOOGLE_API_KEY.trim() === "") {
                throw new Error("API Key æœªè¨­å®šã€‚è«‹ä½¿ç”¨å¾Œç«¯ä¼ºæœå™¨ï¼ˆæ¨è–¦ï¼‰æˆ–åœ¨ç’°å¢ƒè®Šæ•¸ä¸­è¨­å®š GOOGLE_API_KEYï¼ˆåƒ…æœ¬åœ°é–‹ç™¼ç”¨ï¼‰ã€‚");
            }

            const isBibleOnly = mode === 'bible-only';
            const systemInstruction = isBibleOnly ? SYSTEM_PROMPT_BIBLE_ONLY : SYSTEM_PROMPT_WEB_SEARCH;
            
            const contents = [
                ...history.map(msg => ({
                    role: msg.role === 'user' ? 'user' : 'model',
                    parts: [{ text: msg.content }]
                })),
                { role: 'user', parts: [{ text: prompt }] }
            ];

            const payload = {
                contents: contents,
                systemInstruction: { parts: [{ text: systemInstruction }] },
                generationConfig: { 
                    temperature: 0.7, 
                    maxOutputTokens: 2000,
                    topP: 0.95,
                    topK: 40
                }
            };

            if (!isBibleOnly) {
                // æ³¨æ„ï¼šgoogleSearchRetrieval å·²è¢«æ£„ç”¨ï¼Œä½†å‰ç«¯é™ç´šæ–¹æ¡ˆæš«æ™‚ä¸ä½¿ç”¨æœç´¢å·¥å…·
                // å› ç‚ºæœç´¢å·¥å…·éœ€è¦åœ¨å¾Œç«¯é…ç½®
                // payload.tools = [{ googleSearchRetrieval: {} }]; // å·²æ£„ç”¨
                console.log('Web search mode: Using model knowledge without external search tool (fallback mode)');
            }

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GOOGLE_API_KEY}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }
            );

            if (!response.ok) {
                const errData = await response.json().catch(() => ({}));
                const errorMessage = errData.error?.message || `API Error: ${response.status}`;
                
                if (response.status === 401) {
                    throw new Error("API Key ç„¡æ•ˆæˆ–å·²éæœŸï¼Œè«‹æª¢æŸ¥æ‚¨çš„ Google API Key è¨­å®šã€‚");
                } else if (response.status === 429) {
                    throw new Error("API è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
                } else if (response.status === 400) {
                    throw new Error(`è«‹æ±‚æ ¼å¼éŒ¯èª¤ï¼š${errorMessage}`);
                }
                
                throw new Error(errorMessage);
            }

            const data = await response.json();
            let text = data.candidates?.[0]?.content?.parts?.[0]?.text || "ç‰§å¸«æ­£åœ¨é»˜æƒ³ä¸­...(ç„¡æ³•ç”Ÿæˆå›æ‡‰)";
            
            const grounding = data.candidates?.[0]?.groundingMetadata?.groundingAttributions?.map(
                a => ({ uri: a.web?.uri, title: a.web?.title })
            ).filter(a => a.uri) || [];

            return { text, grounding };
        };

        const MessageBubble = ({ role, content, grounding }) => {
            const isUser = role === 'user';
            
            const formatText = (text) => {
                if (!text) return "";
                return text.split('\n').map((line, i) => (
                    <React.Fragment key={i}>
                        {line.split(/(\*\*.*?\*\*)/).map((part, j) => {
                            if (part.startsWith('**') && part.endsWith('**')) {
                                return <strong key={j} className={`font-bold ${isUser ? 'text-amber-50' : 'text-amber-700'}`}>{part.slice(2, -2)}</strong>;
                            }
                            // åŒ¹é…è–ç¶“ç« ç¯€å¼•ç”¨ï¼ˆæ”¯æ´å¤šç¨®æ ¼å¼ï¼‰
                            const bibleRegex = /([^\s\uff08\(\[]+[\u4e00-\u9fa5]+\s?\d+[:ï¼š]\d+)/g;
                            const parts = part.split(bibleRegex);
                            if (parts.length > 1) {
                                return parts.map((p, k) => {
                                    if (p.match(bibleRegex)) {
                                        return <span key={k} className={`font-semibold px-2 py-0.5 rounded-md mx-1 ${
                                            isUser 
                                                ? 'bg-amber-600/30 text-amber-100 border border-amber-400/30' 
                                                : 'text-blue-700 bg-blue-50 border border-blue-200'
                                        }`}>{p}</span>;
                                    }
                                    return p;
                                });
                            }
                            return part;
                        })}
                        <br />
                    </React.Fragment>
                ));
            };

            return (
                <div className={`flex w-full mb-6 message-enter message-3d ${isUser ? 'justify-end' : 'justify-start'}`} style={{ position: 'relative', zIndex: 10 }}>
                    {!isUser && (
                        <div className="flex-shrink-0 mr-2 sm:mr-3 mt-1" style={{ position: 'relative', zIndex: 10 }}>
                            <div className="w-8 h-8 sm:w-10 sm:h-10 rounded-full bg-gradient-to-br from-slate-800 to-slate-900 flex items-center justify-center text-amber-400 shadow-lg border-2 border-amber-500/50 ring-2 ring-amber-500/20 futuristic-glow glow-animate">
                                <Icon name="cross" size={16} className="sm:w-5 sm:h-5" />
                            </div>
                        </div>
                    )}
                    
                    <div className={`max-w-[90%] sm:max-w-[85%] md:max-w-[75%] rounded-3xl px-4 sm:px-5 md:px-6 py-3.5 sm:py-4 md:py-5 ${
                        isUser 
                        ? 'bg-gradient-to-br from-amber-600 via-amber-700 to-amber-800 text-white rounded-br-md shadow-lg shadow-amber-900/30 futuristic-glow' 
                        : 'bg-white/90 text-slate-800 border-2 border-amber-300/30 rounded-bl-md shadow-lg shadow-stone-200/50 backdrop-blur-md futuristic-border'
                    }`} style={{ position: 'relative', zIndex: 10 }}>
                        <div className={`text-xs sm:text-sm md:text-base leading-relaxed font-serif ${!isUser ? 'text-justify' : ''}`}>
                            {formatText(content)}
                        </div>

                        {!isUser && grounding && grounding.length > 0 && (
                            <div className="mt-3 sm:mt-4 pt-3 sm:pt-4 border-t border-stone-100 text-xs text-stone-500">
                                <div className="flex items-center mb-2 sm:mb-2.5 font-semibold text-stone-600">
                                    <Icon name="globe" size={12} className="mr-1.5 text-blue-600" />
                                    <span className="text-xs sm:text-sm">åƒè€ƒè³‡æ–™ä¾†æºï¼š</span>
                                </div>
                                <div className="flex flex-wrap gap-2 sm:gap-2.5">
                                    {grounding.slice(0, 3).map((source, idx) => (
                                        <a 
                                            key={idx} 
                                            href={source.uri} 
                                            target="_blank" 
                                            rel="noopener noreferrer"
                                            className="bg-gradient-to-r from-stone-50 to-stone-100 hover:from-stone-100 hover:to-stone-200 active:from-stone-200 active:to-stone-300 text-stone-700 px-3 py-1.5 rounded-lg transition-all duration-200 truncate max-w-[150px] sm:max-w-[200px] text-xs border border-stone-200/50 shadow-sm hover:shadow-md"
                                        >
                                            {source.title || "Web Source"}
                                        </a>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => {
            // å¾ localStorage è¼‰å…¥æ­·å²å°è©±
            const loadHistory = () => {
                try {
                    const saved = localStorage.getItem('ai-pastor-history');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // åªä¿ç•™æœ€è¿‘ 20 æ¢è¨Šæ¯ä»¥é¿å…éå¤§
                        return parsed.slice(-20);
                    }
                } catch (e) {
                    console.warn('ç„¡æ³•è¼‰å…¥æ­·å²è¨˜éŒ„', e);
                }
                return [
                    { role: 'model', content: 'é¡˜ä¸»èˆ‡ä½ åŒåœ¨ã€‚æˆ‘æ˜¯ä½ çš„ AI ç‰§å¸«ã€‚ç„¡è«–ä½ å¿ƒä¸­æœ‰ä»€éº¼ç–‘å•ï¼Œæˆ–æƒ³å°‹æ±‚è–ç¶“çš„çœŸç†ï¼Œéƒ½è«‹å‘Šè¨´æˆ‘ã€‚\n\nä½ å¯ä»¥é¸æ“‡åƒ…ç”¨è–ç¶“å›ç­”ï¼Œæˆ–æ˜¯çµåˆæ­·å²èˆ‡ç¶²è·¯è³‡æ–™ã€‚è«‹å•ä»Šå¤©æœ‰ä»€éº¼å¯ä»¥å¹«åŠ©ä½ çš„ï¼Ÿ' }
                ];
            };

            const [messages, setMessages] = useState(loadHistory);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [mode, setMode] = useState('bible-only');
            const messagesEndRef = useRef(null);
            const chatAreaRef = useRef(null);

            useEffect(() => {
                lucide.createIcons();
            }, []);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
                lucide.createIcons();
            }, [messages, isLoading]);

            // ä¿å­˜å°è©±æ­·å²åˆ° localStorage
            useEffect(() => {
                try {
                    localStorage.setItem('ai-pastor-history', JSON.stringify(messages));
                } catch (e) {
                    console.warn('ç„¡æ³•ä¿å­˜æ­·å²è¨˜éŒ„', e);
                }
            }, [messages]);

            const handleSend = async (e) => {
                if (e && e.preventDefault) {
                    e.preventDefault();
                }
                if (!input.trim() || isLoading) return;

                const userMessage = input.trim();
                setInput('');
                setIsLoading(true);

                const newMessages = [...messages, { role: 'user', content: userMessage }];
                setMessages(newMessages);

                try {
                    const { text, grounding } = await callGeminiAPI(userMessage, messages, mode);
                    setMessages(prev => [...prev, { role: 'model', content: text, grounding }]);
                } catch (error) {
                    const errorMessage = error.message || 'ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤';
                    setMessages(prev => [...prev, { 
                        role: 'model', 
                        content: `æŠ±æ­‰ï¼Œåœ¨è™•ç†æ‚¨çš„å•é¡Œæ™‚é‡åˆ°å›°é›£ï¼š\n\n**${errorMessage}**\n\nè«‹ç¨å¾Œå†è©¦ï¼Œæˆ–æª¢æŸ¥ API Key è¨­å®šæ˜¯å¦æ­£ç¢ºã€‚` 
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            const clearHistory = () => {
                if (window.confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰å°è©±è¨˜éŒ„å—ï¼Ÿ')) {
                    localStorage.removeItem('ai-pastor-history');
                    setMessages([
                        { role: 'model', content: 'é¡˜ä¸»èˆ‡ä½ åŒåœ¨ã€‚æˆ‘æ˜¯ä½ çš„ AI ç‰§å¸«ã€‚ç„¡è«–ä½ å¿ƒä¸­æœ‰ä»€éº¼ç–‘å•ï¼Œæˆ–æƒ³å°‹æ±‚è–ç¶“çš„çœŸç†ï¼Œéƒ½è«‹å‘Šè¨´æˆ‘ã€‚\n\nä½ å¯ä»¥é¸æ“‡åƒ…ç”¨è–ç¶“å›ç­”ï¼Œæˆ–æ˜¯çµåˆæ­·å²èˆ‡ç¶²è·¯è³‡æ–™ã€‚è«‹å•ä»Šå¤©æœ‰ä»€éº¼å¯ä»¥å¹«åŠ©ä½ çš„ï¼Ÿ' }
                    ]);
                }
            };

            return (
                <div className="flex flex-col h-screen w-full max-w-4xl mx-auto shadow-2xl bg-gradient-to-b from-slate-900/95 via-slate-800/90 to-slate-900/95 overflow-hidden backdrop-blur-xl" style={{ width: '100%', maxWidth: '100%', position: 'relative', overflow: 'hidden', border: '1px solid rgba(255, 215, 0, 0.3)' }}>
                    {/* Header - 3D æœªä¾†æ„Ÿè¨­è¨ˆ */}
                    <header className="bg-gradient-to-r from-slate-900/95 via-slate-800/90 to-slate-900/95 text-amber-50 px-2 sm:px-4 py-0.5 sm:py-1.5 shadow-lg shadow-amber-900/30 flex items-center justify-between z-10 shrink-0 border-b border-amber-500/30 futuristic-border" style={{ height: '38px', minHeight: '38px', maxHeight: '38px', backdropFilter: 'blur(10px)' }}>
                        <div className="flex items-center gap-1 sm:gap-2 min-w-0 flex-1">
                            <div className="bg-gradient-to-br from-amber-500 to-amber-600 p-0.5 sm:p-1 rounded-lg shrink-0 shadow-md shadow-amber-600/30">
                                <Icon name="cross" size={12} className="sm:w-4 sm:h-4 text-white" />
                            </div>
                            <div className="min-w-0">
                                <h1 className="text-xs sm:text-base md:text-xl font-bold tracking-wide font-serif truncate bg-gradient-to-r from-amber-50 to-amber-100 bg-clip-text text-transparent text-3d">AI ç‰§å¸«</h1>
                                <p className="text-xs text-amber-200/80 hidden sm:block glow-animate">ä½ çš„éš¨èº«éˆä¿®å°å¸«</p>
                            </div>
                        </div>
                        <div className="flex items-center gap-1 sm:gap-2 shrink-0">
                            <span className="text-[10px] sm:text-xs text-amber-200/70 whitespace-nowrap">æŒ‰é€™è£¡æ¸…é™¤æ‰€æœ‰å°è©±ç´€éŒ„</span>
                            <button
                                onClick={clearHistory}
                                className="text-xs sm:text-sm text-amber-200/80 hover:text-amber-100 transition-all duration-200 px-1 sm:px-1.5 py-0.5 rounded-lg hover:bg-amber-800/40 active:bg-amber-800/60 active:scale-95 shrink-0 hover:shadow-md"
                                title="æ¸…é™¤å°è©±è¨˜éŒ„"
                            >
                                <Icon name="trash-2" size={12} className="sm:w-3.5 sm:h-3.5" />
                            </button>
                            <div className="text-xs text-slate-400/80 hidden sm:block">è¨ªå®¢æ¨¡å¼</div>
                        </div>
                    </header>

                    {/* Mode Toggle - 3D æœªä¾†æ„Ÿè¨­è¨ˆ */}
                    <div className="mode-toggle-container bg-gradient-to-b from-slate-800/90 to-slate-900/90 p-0.5 sm:p-1.5 border-b border-amber-500/30 flex justify-center shrink-0 shadow-sm futuristic-border" style={{ height: '36px', minHeight: '36px', maxHeight: '36px', backdropFilter: 'blur(10px)' }}>
                         <div className="flex bg-slate-700/40 backdrop-blur-sm p-0.5 sm:p-1 rounded-xl w-full max-w-md shadow-inner futuristic-border">
                            <button
                                onClick={() => setMode('bible-only')}
                                className={`flex-1 flex items-center justify-center px-1 sm:px-2 md:px-4 py-0.5 sm:py-1 md:py-2 rounded-lg text-[10px] sm:text-xs md:text-sm font-medium transition-all duration-200 active:scale-95 ${
                                    mode === 'bible-only' 
                                        ? 'bg-gradient-to-r from-amber-500/80 to-amber-600/80 text-amber-50 shadow-md shadow-amber-500/50 border border-amber-400/50 futuristic-glow' 
                                        : 'text-amber-200/60 hover:text-amber-100 hover:bg-slate-700/50'
                                }`}
                            >
                                <Icon name="book-open" size={10} className="sm:w-3.5 sm:h-3.5 mr-0.5 sm:mr-1" /> 
                                <span className="whitespace-nowrap text-[10px] sm:text-xs md:text-sm">å”¯ç¨è–ç¶“</span>
                            </button>
                            <button
                                onClick={() => setMode('bible-plus')}
                                className={`flex-1 flex items-center justify-center px-1 sm:px-2 md:px-4 py-0.5 sm:py-1 md:py-2 rounded-lg text-[10px] sm:text-xs md:text-sm font-medium transition-all duration-200 active:scale-95 ${
                                    mode === 'bible-plus' 
                                        ? 'bg-gradient-to-r from-blue-500/80 to-blue-600/80 text-blue-50 shadow-md shadow-blue-500/50 border border-blue-400/50 futuristic-glow' 
                                        : 'text-amber-200/60 hover:text-amber-100 hover:bg-slate-700/50'
                                }`}
                            >
                                <Icon name="globe" size={10} className="sm:w-3.5 sm:h-3.5 mr-0.5 sm:mr-1" /> 
                                <span className="whitespace-nowrap text-[10px] sm:text-xs md:text-sm">è–ç¶“+ç¶²è·¯</span>
                            </button>
                        </div>
                    </div>

                    {/* Chat Area - ä½¿ç”¨ flex-1 ç¢ºä¿ä½”ç”¨å‰©é¤˜ç©ºé–“ï¼Œä¸æ“ å£“å›ºå®šå…ƒç´  */}
                    <div ref={chatAreaRef} className="chat-area flex-1 overflow-y-auto px-2 sm:px-4 py-1 sm:py-2 md:py-4 scrollbar-thin min-h-0 relative" style={{ position: 'relative', overflowY: 'auto' }}>
                        {/* è–èª•ç¯€æœªä¾†æ„ŸèƒŒæ™¯ - çµ•å°å®šä½åœ¨èƒŒæ™¯å±¤ï¼Œç¢ºä¿ä¸é˜»æ“‹å…§å®¹ */}
                        <div style={{ 
                            position: 'absolute', 
                            top: 0, 
                            left: 0, 
                            right: 0, 
                            bottom: 0, 
                            zIndex: 0, 
                            pointerEvents: 'none',
                            overflow: 'hidden',
                            backgroundColor: '#000000', // æ·±é»‘è‰²èƒŒæ™¯
                            width: '100%',
                            height: '100%'
                        }}>
                            {/* å„ªå…ˆä½¿ç”¨ 3Dï¼Œå¤±æ•—å‰‡ä½¿ç”¨ 2D è–èª•ç¯€èƒŒæ™¯ */}
                            <FuturisticScene containerRef={chatAreaRef} />
                            {/* 2D è–èª•ç¯€èƒŒæ™¯ä½œç‚ºå‚™ç”¨ï¼ˆç¢ºä¿ç¸½æ˜¯æœ‰èƒŒæ™¯é¡¯ç¤ºï¼‰ */}
                            <ChristmasBackground2D containerRef={chatAreaRef} />
                        </div>
                        
                        {/* "Merry Christmas!" æ–‡å­—ï¼ˆCSS å‹•ç•«æ•ˆæœï¼ŒæŒ‰ç…§æ‚¨æä¾›çš„ä»£ç¢¼ï¼‰ */}
                        <div id="merry-christmas-text" style={{
                            position: 'absolute',
                            top: '50%',
                            left: '10%',
                            transform: 'translateY(-50%)',
                            color: '#FFB6C1',
                            fontFamily: "'Brush Script MT', 'Noto Serif TC', cursive",
                            fontSize: 'clamp(1.5rem, 4vw, 3rem)',
                            pointerEvents: 'none',
                            textShadow: '0 0 10px #ff0055, 0 0 20px #ff0055',
                            zIndex: 5,
                            mixBlendMode: 'overlay',
                            opacity: 0.8,
                            background: 'linear-gradient(to right, #666 0%, #fff 50%, #666 100%)',
                            backgroundSize: '200% auto',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent',
                            animation: 'shine 3s linear infinite'
                        }}>
                            Merry Christmas!
                        </div>
                        
                        {/* è¨Šæ¯å…§å®¹ï¼ˆåœ¨ç²’å­ä¹‹ä¸Šï¼‰ - ç¢ºä¿æœ‰æ­£ç¢ºçš„ z-index å’Œå®šä½ */}
                        <div style={{ 
                            position: 'relative', 
                            zIndex: 10, 
                            width: '100%',
                            minHeight: '100%'
                        }}>
                            {messages && messages.length > 0 ? (
                                <>
                                    {messages.map((msg, index) => (
                                        <MessageBubble key={index} role={msg.role} content={msg.content} grounding={msg.grounding} />
                                    ))}
                                    {isLoading && (
                                        <div className="flex w-full justify-start mb-4 sm:mb-6 message-enter">
                                            <div className="flex-shrink-0 mr-2 sm:mr-3 mt-1">
                                                <div className="w-8 h-8 sm:w-10 sm:h-10 rounded-full bg-gradient-to-br from-slate-800 to-slate-900 flex items-center justify-center text-amber-400 border-2 border-amber-500/50 ring-2 ring-amber-500/20 shadow-lg">
                                                    <Icon name="loader-2" size={16} className="sm:w-5 sm:h-5 animate-spin" />
                                                </div>
                                            </div>
                                            <div className="bg-gradient-to-br from-white to-stone-50 border border-stone-200/80 rounded-3xl rounded-bl-md px-4 sm:px-5 py-3 sm:py-4 shadow-lg shadow-stone-200/50 backdrop-blur-sm text-xs sm:text-sm text-stone-600">
                                                <span className="inline-flex items-center gap-2">
                                                    <span className="animate-pulse">ç‰§å¸«æ­£åœ¨æŸ¥è€ƒç¶“æ–‡</span>
                                                    <span className="flex gap-1">
                                                        <span className="w-1 h-1 bg-amber-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></span>
                                                        <span className="w-1 h-1 bg-amber-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></span>
                                                        <span className="w-1 h-1 bg-amber-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></span>
                                                    </span>
                                                </span>
                                            </div>
                                        </div>
                                    )}
                                    <div ref={messagesEndRef} />
                                </>
                            ) : (
                                <div className="flex items-center justify-center h-full">
                                    <div className="text-stone-400 text-sm">è¼‰å…¥ä¸­...</div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Input Area - 3D æœªä¾†æ„Ÿè¨­è¨ˆ */}
                    <div className="input-container bg-gradient-to-t from-slate-900/95 via-slate-800/90 to-slate-900/95 border-t border-amber-500/30 shrink-0 safe-area-inset-bottom shadow-lg shadow-amber-900/30 futuristic-border" style={{ minHeight: '60px', maxHeight: '60px', padding: '0.375rem', backdropFilter: 'blur(10px)' }}>
                        <form onSubmit={handleSend} className="relative flex items-end gap-1 sm:gap-2">
                            <div className="flex-1 relative">
                                <textarea
                                    value={input}
                                    onChange={(e) => setInput(e.target.value)}
                                    onKeyDown={(e) => {
                                        // æŒ‰ Enter ç™¼é€ï¼ˆShift+Enter æ›è¡Œï¼‰
                                        if (e.key === 'Enter' && !e.shiftKey) {
                                            e.preventDefault();
                                            handleSend(e);
                                        }
                                    }}
                                    placeholder="è«‹è¼¸å…¥æ‚¨çš„å•é¡Œ..."
                                    rows={3}
                                    className="w-full py-1 sm:py-1.5 md:py-3 pl-2 sm:pl-4 md:pl-5 pr-8 sm:pr-11 md:pr-14 rounded-2xl bg-gradient-to-br from-stone-50 to-stone-100 border border-stone-300/80 focus:border-amber-500 focus:ring-2 focus:ring-amber-200/50 outline-none transition-all duration-200 resize-none overflow-y-auto font-serif shadow-inner placeholder:text-stone-400"
                                    disabled={isLoading}
                                    style={{ 
                                        minHeight: '2.25rem', 
                                        maxHeight: '2.5rem',
                                        lineHeight: '1.3',
                                        fontSize: '0.8rem'
                                    }}
                                />
                            </div>
                            <button
                                type="submit"
                                disabled={!input.trim() || isLoading}
                                className={`p-2 sm:p-2.5 md:p-3 rounded-full shadow-lg transition-all duration-200 active:scale-90 shrink-0 mb-0.5 sm:mb-1 ${
                                    !input.trim() || isLoading
                                    ? 'bg-gradient-to-br from-slate-700 to-slate-800 text-slate-400 cursor-not-allowed border border-slate-600/50'
                                    : 'bg-gradient-to-br from-amber-600 via-amber-700 to-amber-800 hover:from-amber-700 hover:via-amber-800 hover:to-amber-900 active:from-amber-800 active:via-amber-900 active:to-amber-950 text-white shadow-amber-900/30 hover:shadow-xl hover:shadow-amber-900/40 hover:scale-105 futuristic-glow border-2 border-amber-400/50'
                                }`}
                            >
                                <Icon name="send" size={16} className="sm:w-4 sm:h-4 md:w-5 md:h-5" />
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

